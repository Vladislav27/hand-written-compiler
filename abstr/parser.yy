%skeleton "lalr1.cc"%require  "3.0"%debug%defines%define api.namespace {Comp}%define parser_class_name {CParser}%code requires{    namespace Comp {       class CDriver;       class CScanner;    }    #include <abstr/Location.h>    using NTree::ConvertLocation;    #include <abstr/Symbol.h>    #include <abstr/tree/Class.h>    #include <abstr/tree/Common.h>    #include <abstr/tree/Expression.h>    #include <abstr/tree/Program.h>    #include <abstr/tree/Statement.h>    #include <abstr/tree/Type.h>    #include <abstr/tree/MethodDeclaration.h>    #include <abstr/tree/VarDeclaration.h>}%parse-param { CScanner  &scanner  }%parse-param { CDriver  &driver  }%parse-param { NTree::Program &program }%code{   #include <iostream>   #include <cstdlib>   #include <fstream>   /* include for all driver functions */   #include "CDriver.h"    #undef yylex    #define yylex scanner.yylex}%define api.value.type variant%token               END    0     "end of file"%token               LITTER%token               DIGIT%token <int>         NUMBER%token               WS%token               COMMENT%token               STRING%token               SEMI%token               COMMA%token               ASSIGN%token               EQUAL%token               LPAREN%token               RPAREN%token               LBRACE%token               RBRACE%token               IF%token               ELSE%token               TRUE%token               FALSE%token               INT%token               BOOL%token               CLASS%token               EXTENDS%token               RETURN%token <NTree::Symbol*>     ID%token               PLUS%token               MINUS%token               MULT%token               AND%token               OR%token               LESS%token               MOD%token               LBRACKET%token               RBRACKET%token               WHILE%token               INTARRAY%token               TSTRING%token               TSTRINGARRAY%token               PUBLIC%token               PRIVATE%token               THIS%token               NEW%token               MAIN%token               PRINT%token               VOID%token               STATIC%token               NOT%token               DOT%token               LENGTH%type<NTree::MainClass*> MainClass;%type<std::vector<std::unique_ptr<NTree::ClassDeclaration>>*> ClassDeclarations;%type<NTree::ClassDeclaration*> ClassDeclaration;%type<std::vector<std::unique_ptr<NTree::VarDeclaration>>*> VarDeclarations NotEmptyVarDeclarationList ArgumentList NotEmptyArgumentList;%type<NTree::VarDeclaration*> VarDeclaration;%type<NTree::Type> Type;%type<std::vector<std::unique_ptr<NTree::MethodDeclaration>>*> MethodDeclarations;%type<NTree::MethodDeclaration*> MethodDeclaration;%type<std::vector<std::unique_ptr<NTree::IStatement>>*> Statements NotEmptyStatementList;%type<NTree::IStatement*> Statement;%type<NTree::IExpression*> Expression;%type<std::vector<std::unique_ptr<NTree::IExpression>>*> ArgumentExpressions NotEmptyArgumentExpressions;%locations%nonassoc OR%nonassoc AND%left PLUS MINUS%left MULT%right NOT%left DOT%left LBRACKET%nonassoc ASSIGN%nonassoc LESS%%Goal    : MainClass ClassDeclarations END {        program.location = ConvertLocation(@$);        program.mainClass.reset($1);        program.classes.reset($2);    };MainClass    : CLASS ID[name] LBRACE        PUBLIC STATIC VOID MAIN LPAREN TSTRINGARRAY ID[args] RPAREN LBRACE            Statement        RBRACE    RBRACE {        $$ = new NTree::MainClass(ConvertLocation(@$), $name, $args, $Statement);    };ClassDeclarations    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::ClassDeclaration>>();    }    | ClassDeclarations ClassDeclaration {        $$ = $1;        $$->emplace_back($2);    };ClassDeclaration    : CLASS ID[name] LBRACE        VarDeclarations        MethodDeclarations    RBRACE {        $$ = new NTree::ClassDeclaration(ConvertLocation(@$), $name, nullptr, $VarDeclarations, $MethodDeclarations);    }    | CLASS ID[name] EXTENDS ID[parent] LBRACE        VarDeclarations        MethodDeclarations    RBRACE {        $$ = new NTree::ClassDeclaration(ConvertLocation(@$), $name, $parent, $VarDeclarations, $MethodDeclarations);    };NotEmptyVarDeclarationList    : VarDeclaration {        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        $$->emplace_back($1);    }    | NotEmptyVarDeclarationList VarDeclaration {        $$ = $1;        $$->emplace_back($2);    };VarDeclarations    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();    }    | NotEmptyVarDeclarationList {        $$ = $1;    };VarDeclaration    : Type ID SEMI {        $$ = new NTree::VarDeclaration(ConvertLocation(@$), $1, $2);    };Type    : INT {        $$ = NTree::Type{NTree::EType::INT, nullptr};    }    | INTARRAY {        $$ = NTree::Type{NTree::EType::INT_ARRAY, nullptr};    }    | BOOL {        $$ = NTree::Type{NTree::EType::BOOL, nullptr};    }    | ID {        $$ = NTree::Type{NTree::EType::CLASS, $1};    };MethodDeclarations    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::MethodDeclaration>>();    }    | MethodDeclarations MethodDeclaration {        $$ = $1;        $$->emplace_back($2);    };MethodDeclaration    : PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyVarDeclarationList        NotEmptyStatementList        RETURN Expression SEMI    RBRACE {        $$ = new NTree::MethodDeclaration(ConvertLocation(@$), $type, $name, $ArgumentList, $NotEmptyVarDeclarationList, $NotEmptyStatementList, $Expression);    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyStatementList        RETURN Expression SEMI    RBRACE {        auto varDeclarations = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        $$ = new NTree::MethodDeclaration(ConvertLocation(@$), $type, $name, $ArgumentList, varDeclarations, $NotEmptyStatementList, $Expression);    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyVarDeclarationList        RETURN Expression SEMI    RBRACE {        auto statements = new std::vector<std::unique_ptr<NTree::IStatement>>();        $$ = new NTree::MethodDeclaration(ConvertLocation(@$), $type, $name, $ArgumentList, $NotEmptyVarDeclarationList, statements, $Expression);    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        RETURN Expression SEMI    RBRACE {        auto varDeclarations = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        auto statements = new std::vector<std::unique_ptr<NTree::IStatement>>();        $$ = new NTree::MethodDeclaration(ConvertLocation(@$), $type, $name, $ArgumentList, varDeclarations, statements, $Expression);    };NotEmptyArgumentList    : Type ID {        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        $$->emplace_back(new NTree::VarDeclaration(ConvertLocation(@$), $Type, $ID));    }    | NotEmptyArgumentList COMMA Type ID {        $$ = $1;        $$->emplace_back(new NTree::VarDeclaration(ConvertLocation(@$), $Type, $ID));    };ArgumentList    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();    }    | NotEmptyArgumentList {        $$ = $1;    };NotEmptyStatementList    : Statement {        $$ = new std::vector<std::unique_ptr<NTree::IStatement>>();        $$->emplace_back($1);    }    | NotEmptyStatementList Statement {        $$ = $1;        $$->emplace_back($2);    }Statements    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::IStatement>>();    }    | NotEmptyStatementList {        $$ = $1;    };Statement    : LBRACE Statements RBRACE {        $$ = new NTree::Statements(ConvertLocation(@$), $Statements);    }    | IF LPAREN Expression RPAREN Statement[trueStatement] ELSE Statement[falseStatement] {        $$ = new NTree::IfStatement(ConvertLocation(@$), $Expression, $trueStatement, $falseStatement);    }    | WHILE LPAREN Expression RPAREN Statement[statement] {        $$ = new NTree::WhileStatement(ConvertLocation(@$), $Expression, $statement);    }    | PRINT LPAREN Expression RPAREN SEMI {        $$ = new NTree::PrintlnStatement(ConvertLocation(@$), $Expression);    }    | ID ASSIGN Expression SEMI {        $$ = new NTree::AssignStatement(ConvertLocation(@$), $1, $3);    }    | ID LBRACKET Expression[index] RBRACKET ASSIGN Expression[rvalue] SEMI {        $$ = new NTree::ArrayElementAssignmentStatement(ConvertLocation(@$), $1, $index, $rvalue);    };Expression    : Expression[left] AND Expression[right] {        $$ = new NTree::BinaryExpression(ConvertLocation(@$), NTree::EBinaryExprType::AND, $left, $right);    }    | Expression[left] LESS Expression[right] {        $$ = new NTree::BinaryExpression(ConvertLocation(@$), NTree::EBinaryExprType::LESS, $left, $right);    }    | Expression[left] PLUS Expression[right] {        $$ = new NTree::BinaryExpression(ConvertLocation(@$), NTree::EBinaryExprType::PLUS, $left, $right);    }    | Expression[left] MINUS Expression[right] {        $$ = new NTree::BinaryExpression(ConvertLocation(@$), NTree::EBinaryExprType::MINUS, $left, $right);    }    | Expression[left] MULT Expression[right] {        $$ = new NTree::BinaryExpression(ConvertLocation(@$), NTree::EBinaryExprType::MULTIPLY, $left, $right);    }    | Expression[array] LBRACKET Expression[index] RBRACKET {        $$ = new NTree::ArrayElementAccessExpression(ConvertLocation(@$), $array, $index);    }    | Expression[array] DOT LENGTH {        $$ = new NTree::ArrayLengthExpression(ConvertLocation(@$), $1);    }    | Expression[object] DOT ID[methodName] LPAREN ArgumentExpressions[args] RPAREN {        $$ = new NTree::MethodCallExpression(ConvertLocation(@$), $object, $methodName, $args);    }    | NUMBER {        $$ = new NTree::IntegerLiteralExpression(ConvertLocation(@$), $1);    }    | TRUE {        $$ = new NTree::BoolLiteralExpression(ConvertLocation(@$), true);    }    | FALSE {        $$ = new NTree::BoolLiteralExpression(ConvertLocation(@$), false);    }    | ID {        $$ = new NTree::IdentifierExpression(ConvertLocation(@$), $1);    }    | THIS {        $$ = new NTree::ThisExpression(ConvertLocation(@$));    }    | NEW INT LBRACKET Expression[size] RBRACKET {        $$ = new NTree::NewIntArrayExpression(ConvertLocation(@$), $size);    }    | NEW ID[clazz] LPAREN RPAREN {        $$ = new NTree::NewExpression(ConvertLocation(@$), $clazz);    }    | NOT Expression[expression] {        $$ = new NTree::NegateExpression(ConvertLocation(@$), $expression);    }    | LPAREN Expression[expression] RPAREN {        $$ = $expression;    };NotEmptyArgumentExpressions    : Expression {        $$ = new std::vector<std::unique_ptr<NTree::IExpression>>();        $$->emplace_back($1);    }    | ArgumentExpressions COMMA Expression {        $$ = $1;        $$->emplace_back($3);    };ArgumentExpressions    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::IExpression>>();    }    | NotEmptyArgumentExpressions {        $$ = $1;    };%%void Comp::CParser::error( const location_type &l, const std::string &err_message ){   std::cerr << "Error: " << err_message << " at " << l << "\n";}