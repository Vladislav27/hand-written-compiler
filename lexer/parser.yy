%skeleton "lalr1.cc"%require  "3.0"%debug%defines%define api.namespace {Comp}%define parser_class_name {CParser}%code requires{   namespace Comp {      class CDriver;      class CScanner;   }    #include <lexer/Symbol.h>    #include <lexer/tree/Class.h>    #include <lexer/tree/Common.h>    #include <lexer/tree/Expression.h>    #include <lexer/tree/Program.h>    #include <lexer/tree/Statement.h>    #include <lexer/tree/Type.h>    #include <lexer/tree/MethodDeclaration.h>    #include <lexer/tree/VarDeclaration.h>}%parse-param { CScanner  &scanner  }%parse-param { CDriver  &driver  }%parse-param { NTree::Program &program }%code{   #include <iostream>   #include <cstdlib>   #include <fstream>   /* include for all driver functions */   #include "CDriver.h"    #undef yylex    #define yylex scanner.yylex}%define api.value.type variant%token               END    0     "end of file"%token               LITTER%token               DIGIT%token <int>         NUMBER%token               WS%token               COMMENT%token               STRING%token               SEMI%token               COMMA%token               ASSIGN%token               EQUAL%token               LPAREN%token               RPAREN%token               LBRACE%token               RBRACE%token               IF%token               ELSE%token               TRUE%token               FALSE%token               INT%token               BOOL%token               CLASS%token               EXTENDS%token               RETURN%token <NTree::Symbol*>     ID%token               PLUS%token               MINUS%token               MULT%token               AND%token               OR%token               LESS%token               MOD%token               LBRACKET%token               RBRACKET%token               WHILE%token               INTARRAY%token               TSTRING%token               TSTRINGARRAY%token               PUBLIC%token               PRIVATE%token               THIS%token               NEW%token               MAIN%token               PRINT%token               NOT%token               DOT%token               LENGTH%type<NTree::MainClass*> MainClass;%type<std::vector<std::unique_ptr<NTree::ClassDeclaration>>*> ClassDeclarations;%type<NTree::ClassDeclaration*> ClassDeclaration;%type<std::vector<std::unique_ptr<NTree::VarDeclaration>>*> VarDeclarations NotEmptyVarDeclarationList ArgumentList NotEmptyArgumentList;%type<NTree::VarDeclaration*> VarDeclaration;%type<NTree::Type> Type;%type<std::vector<std::unique_ptr<NTree::MethodDeclaration>>*> MethodDeclarations;%type<NTree::MethodDeclaration*> MethodDeclaration;%type<std::vector<std::unique_ptr<NTree::IStatement>>*> Statements NotEmptyStatementList;%type<NTree::IStatement*> Statement;%type<NTree::IExpression*> Expression;%type<std::vector<std::unique_ptr<NTree::IExpression>>*> ArgumentExpressions NotEmptyArgumentExpressions;%locations%nonassoc OR%nonassoc AND%left PLUS MINUS%left MULT%right NOT%left DOT%left LBRACKET%nonassoc ASSIGN%nonassoc LESS%%Goal    : MainClass ClassDeclarations END {        program.mainClass.reset($1);        program.classes.reset($2);    };MainClass    : CLASS ID[name] LBRACE        MAIN LPAREN TSTRINGARRAY ID[args] RPAREN LBRACE            Statement        RBRACE    RBRACE {        $$ = new NTree::MainClass($name, $args, $Statement);    };ClassDeclarations    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::ClassDeclaration>>();    }    | ClassDeclarations ClassDeclaration {        $$ = $1;        $$->emplace_back($2);    };ClassDeclaration    : CLASS ID[name] LBRACE        VarDeclarations        MethodDeclarations    RBRACE {        $$ = new NTree::ClassDeclaration($name, nullptr, $VarDeclarations, $MethodDeclarations);    }    | CLASS ID[name] EXTENDS ID[parent] LBRACE        VarDeclarations        MethodDeclarations    RBRACE {        $$ = new NTree::ClassDeclaration($name, $parent, $VarDeclarations, $MethodDeclarations);    };NotEmptyVarDeclarationList    : VarDeclaration {        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        $$->emplace_back($1);    }    | NotEmptyVarDeclarationList VarDeclaration {        $$ = $1;        $$->emplace_back($2);    };VarDeclarations    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();    }    | NotEmptyVarDeclarationList {        $$ = $1;    };VarDeclaration    : Type ID SEMI {        $$ = new NTree::VarDeclaration($1, $2);    };Type    : INT {        $$ = NTree::Type{NTree::EType::INT, nullptr};    }    | INTARRAY {        $$ = NTree::Type{NTree::EType::INT_ARRAY, nullptr};    }    | BOOL {        $$ = NTree::Type{NTree::EType::BOOL, nullptr};    }    | ID {        $$ = NTree::Type{NTree::EType::CLASS, $1};    };MethodDeclarations    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::MethodDeclaration>>();    }    | MethodDeclarations MethodDeclaration {        $$ = $1;        $$->emplace_back($2);    };MethodDeclaration    : PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyVarDeclarationList        NotEmptyStatementList        RETURN Expression SEMI    RBRACE {        $$ = new NTree::MethodDeclaration($type, $name, $ArgumentList, $NotEmptyVarDeclarationList, $NotEmptyStatementList, $Expression);    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyStatementList        RETURN Expression SEMI    RBRACE {        auto varDeclarations = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        $$ = new NTree::MethodDeclaration($type, $name, $ArgumentList, varDeclarations, $NotEmptyStatementList, $Expression);    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyVarDeclarationList        RETURN Expression SEMI    RBRACE {        auto statements = new std::vector<std::unique_ptr<NTree::IStatement>>();        $$ = new NTree::MethodDeclaration($type, $name, $ArgumentList, $NotEmptyVarDeclarationList, statements, $Expression);    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        RETURN Expression SEMI    RBRACE {        auto varDeclarations = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        auto statements = new std::vector<std::unique_ptr<NTree::IStatement>>();        $$ = new NTree::MethodDeclaration($type, $name, $ArgumentList, varDeclarations, statements, $Expression);    };NotEmptyArgumentList    : Type ID {        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        $$->emplace_back(new NTree::VarDeclaration($Type, $ID));    }    | NotEmptyArgumentList COMMA Type ID {        $$ = $1;        $$->emplace_back(new NTree::VarDeclaration($Type, $ID));    };ArgumentList    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();    }    | NotEmptyArgumentList {        $$ = $1;    };NotEmptyStatementList    : Statement {        $$ = new std::vector<std::unique_ptr<NTree::IStatement>>();        $$->emplace_back($1);    }    | NotEmptyStatementList Statement {        $$ = $1;        $$->emplace_back($2);    }Statements    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::IStatement>>();    }    | NotEmptyStatementList {        $$ = $1;    };Statement    : LBRACE Statements RBRACE {        $$ = new NTree::Statements($Statements);    }    | IF LPAREN Expression RPAREN Statement[trueStatement] ELSE Statement[falseStatement] {        $$ = new NTree::IfStatement($Expression, $trueStatement, $falseStatement);    }    | WHILE LPAREN Expression RPAREN Statement[statement] {        $$ = new NTree::WhileStatement($Expression, $statement);    }    | PRINT LPAREN Expression RPAREN SEMI {        $$ = new NTree::PrintlnStatement($Expression);    }    | ID ASSIGN Expression SEMI {        $$ = new NTree::AssignStatement($1, $3);    }    | ID LBRACKET Expression[index] RBRACKET ASSIGN Expression[rvalue] SEMI {        $$ = new NTree::ArrayElementAssignmentStatement($1, $index, $rvalue);    };Expression    : Expression[left] AND Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::AND, $left, $right);    }    | Expression[left] LESS Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::LESS, $left, $right);    }    | Expression[left] PLUS Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::PLUS, $left, $right);    }    | Expression[left] MINUS Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::MINUS, $left, $right);    }    | Expression[left] MULT Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::MULTIPLY, $left, $right);    }    | Expression[array] LBRACKET Expression[index] RBRACKET {        $$ = new NTree::ArrayElementAccessExpression($array, $index);    }    | Expression[array] DOT LENGTH {        $$ = new NTree::ArrayLengthExpression($1);    }    | Expression[object] DOT ID[methodName] LPAREN ArgumentExpressions[args] RPAREN {        $$ = new NTree::MethodCallExpression($object, $methodName, $args);    }    | NUMBER {        $$ = new NTree::IntegerLiteralExpression($1);    }    | TRUE {        $$ = new NTree::BoolLiteralExpression(true);    }    | FALSE {        $$ = new NTree::BoolLiteralExpression(false);    }    | ID {        $$ = new NTree::IdentifierExpression($1);    }    | THIS {        $$ = new NTree::ThisExpression();    }    | NEW INT LBRACKET Expression[size] RBRACKET {        $$ = new NTree::NewIntArrayExpression($size);    }    | NEW ID[clazz] LPAREN RPAREN {        $$ = new NTree::NewExpression($clazz);    }    | NOT Expression[expression] {        $$ = new NTree::NegateExpression($expression);    }    | LPAREN Expression[expression] RPAREN {        $$ = $expression;    };NotEmptyArgumentExpressions    : Expression {        $$ = new std::vector<std::unique_ptr<NTree::IExpression>>();        $$->emplace_back($1);    }    | ArgumentExpressions COMMA Expression {        $$ = $1;        $$->emplace_back($3);    };ArgumentExpressions    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::IExpression>>();    }    | NotEmptyArgumentExpressions {        $$ = $1;    };%%void Comp::CParser::error( const location_type &l, const std::string &err_message ){   std::cerr << "Error: " << err_message << " at " << l << "\n";}