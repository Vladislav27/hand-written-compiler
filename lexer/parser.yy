%skeleton "lalr1.cc"%require  "3.0"%debug%defines%define api.namespace {Comp}%define parser_class_name {CParser}%code requires{   namespace Comp {      class CDriver;      class CScanner;   }    #include <lexer/Symbol.h>    #include <lexer/tree/Class.h>    #include <lexer/tree/Common.h>    #include <lexer/tree/Expression.h>    #include <lexer/tree/Program.h>    #include <lexer/tree/Statement.h>    #include <lexer/tree/Type.h>    #include <lexer/tree/VarDeclaration.h>}%parse-param { CScanner  &scanner  }%parse-param { CDriver  &driver  }%parse-param { NTree::Program &program }%code{   #include <iostream>   #include <cstdlib>   #include <fstream>   /* include for all driver functions */   #include "CDriver.h"    #undef yylex    #define yylex scanner.yylex}%define api.value.type variant%token               END    0     "end of file"%token               LITTER%token               DIGIT%token <int>         NUMBER%token               WS%token               COMMENT%token               STRING%token               SEMI%token               COMMA%token               ASSIGN%token               EQUAL%token               LPAREN%token               RPAREN%token               LBRACE%token               RBRACE%token               IF%token               ELSE%token               TRUE%token               FALSE%token               INT%token               BOOL%token               CLASS%token               EXTENDS%token               RETURN%token <NTree::Symbol*>     ID%token               PLUS%token               MINUS%token               MULT%token               AND%token               OR%token               LESS%token               MOD%token               LBRACKET%token               RBRACKET%token               WHILE%token               INTARRAY%token               TSTRING%token               TSTRINGARRAY%token               PUBLIC%token               PRIVATE%token               THIS%token               NEW%token               MAIN%token               PRINT%token               NOT%token               DOT%token               LENGTH%type<NTree::MainClass*> MainClass;%type<std::vector<std::unique_ptr<NTree::VarDeclaration>>*> VarDeclarations NotEmptyVarDeclarationList ArgumentList NotEmptyArgumentList;%type<NTree::VarDeclaration*> VarDeclaration;%type<NTree::Type> Type;%type<std::vector<std::unique_ptr<NTree::IStatement>>*> Statements NotEmptyStatementList;%type<NTree::IStatement*> Statement;%type<NTree::IExpression*> Expression;%type<std::vector<std::unique_ptr<NTree::IExpression>>*> ArgumentExpressions NotEmptyArgumentExpressions;%locations%nonassoc OR%nonassoc AND%left PLUS MINUS%left MULT%right NOT%left DOT%left LBRACKET%nonassoc ASSIGN%nonassoc LESS%%Goal    : MainClass ClassDeclarations END {        program.mainClass.reset($1);    };MainClass    : CLASS ID[name] LBRACE        MAIN LPAREN TSTRINGARRAY ID[args] RPAREN LBRACE            Statement        RBRACE    RBRACE {        std::cout<<"Parser:Main"<<std::endl;        $$ = new NTree::MainClass($name, $args, $Statement);    };ClassDeclarations    : %empty {    }    | ClassDeclarations ClassDeclaration {    };ClassDeclaration    : CLASS ID[name] LBRACE        VarDeclarations        MethodDeclarations    RBRACE {    }    | CLASS ID[name] EXTENDS ID[parent] LBRACE        VarDeclarations        MethodDeclarations    RBRACE {    };NotEmptyVarDeclarationList    : VarDeclaration {        std::cout<<"Parser:VarDeclaration"<<std::endl;        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        $$->emplace_back($1);    }    | NotEmptyVarDeclarationList VarDeclaration {        std::cout<<"Parser:VarDeclarationNotEmpty"<<std::endl;        $$ = $1;        $$->emplace_back($2);    };VarDeclarations    : %empty {        std::cout<<"Parser:VarDeclarationsEmpty"<<std::endl;        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();    }    | NotEmptyVarDeclarationList {        std::cout<<"Parser:NotEmptyVarDeclarationList"<<std::endl;        $$ = $1;    };VarDeclaration    : Type ID SEMI {        std::cout<<"Parser:VarDeclaration Type ID"<<std::endl;        $$ = new NTree::VarDeclaration($1, $2);    };Type    : INT {        std::cout<<"Parser:Type INT"<<std::endl;        $$ = NTree::Type{NTree::EType::INT, nullptr};    }    | INTARRAY {        std::cout<<"Parser:Type INTARRAY"<<std::endl;        $$ = NTree::Type{NTree::EType::INT_ARRAY, nullptr};    }    | BOOL {        std::cout<<"Parser:Type BOOL"<<std::endl;        $$ = NTree::Type{NTree::EType::BOOL, nullptr};    }    | ID {        std::cout<<"Parser:Type ID"<<std::endl;        $$ = NTree::Type{NTree::EType::CLASS, $1};    };MethodDeclarations    : %empty {    }    | MethodDeclarations MethodDeclaration {    };MethodDeclaration    : PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyVarDeclarationList        NotEmptyStatementList        RETURN Expression SEMI    RBRACE {    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyStatementList        RETURN Expression SEMI    RBRACE {    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyVarDeclarationList        RETURN Expression SEMI    RBRACE {    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        RETURN Expression SEMI    RBRACE {    };NotEmptyArgumentList    : Type ID {        std::cout<<"Parser:NotEmptyArgumentList Type ID"<<std::endl;        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();        $$->emplace_back(new NTree::VarDeclaration($Type, $ID));    }    | NotEmptyArgumentList COMMA Type ID {        std::cout<<"Parser:NotEmptyArgumentList COMMA Type ID"<<std::endl;        $$ = $1;        $$->emplace_back(new NTree::VarDeclaration($Type, $ID));    };ArgumentList    : %empty {        std::cout<<"Parser:ArgumentList empty"<<std::endl;        $$ = new std::vector<std::unique_ptr<NTree::VarDeclaration>>();    }    | NotEmptyArgumentList {        std::cout<<"Parser:ArgumentList NotEmptyList"<<std::endl;        $$ = $1;    };NotEmptyStatementList    : Statement {        std::cout<<"Parser:NotEmptyStatementList Statement"<<std::endl;        $$ = new std::vector<std::unique_ptr<NTree::IStatement>>();        $$->emplace_back($1);    }    | NotEmptyStatementList Statement {        std::cout<<"Parser:NotEmptyStatementList NotEmptyStatementList Statement"<<std::endl;        $$ = $1;        $$->emplace_back($2);    }Statements    : %empty {        std::cout<<"Parser:Statements empty"<<std::endl;        $$ = new std::vector<std::unique_ptr<NTree::IStatement>>();    }    | NotEmptyStatementList {        std::cout<<"Parser:Statements NotEmptyStatementList"<<std::endl;        $$ = $1;    };Statement    : LBRACE Statements RBRACE {        std::cout<<"Parser:Statement Statements"<<std::endl;        $$ = new NTree::Statements($Statements);    }    | IF LPAREN Expression RPAREN Statement[trueStatement] ELSE Statement[falseStatement] {    }    | WHILE LPAREN Expression RPAREN Statement[statement] {    }    | PRINT LPAREN Expression RPAREN SEMI {    }    | ID ASSIGN Expression SEMI {        std::cout<<"Parser:Statement Assign"<<std::endl;        $$ = new NTree::AssignStatement($1, $3);    }    | ID LBRACKET Expression[index] RBRACKET ASSIGN Expression[rvalue] SEMI {    };Expression    : Expression[left] AND Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::AND, $left, $right);    }    | Expression[left] LESS Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::LESS, $left, $right);    }    | Expression[left] PLUS Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::PLUS, $left, $right);    }    | Expression[left] MINUS Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::MINUS, $left, $right);    }    | Expression[left] MULT Expression[right] {        $$ = new NTree::BinaryExpression(NTree::EBinaryExprType::MULTIPLY, $left, $right);    }    | Expression[array] LBRACKET Expression[index] RBRACKET {    }    | Expression[array] DOT LENGTH {    }    | Expression[object] DOT ID[methodName] LPAREN ArgumentExpressions[args] RPAREN {    }    | NUMBER {        $$ = new NTree::IntegerLiteralExpression($1);    }    | TRUE {        $$ = new NTree::BoolLiteralExpression(true);    }    | FALSE {        $$ = new NTree::BoolLiteralExpression(false);    }    | ID {        $$ = new NTree::IdentifierExpression($1);    }    | THIS {    }    | NEW INT LBRACKET Expression[size] RBRACKET {    }    | NEW ID[clazz] LPAREN RPAREN {    }    | NOT Expression[expression] {        $$ = new NTree::NegateExpression($expression);    }    | LPAREN Expression[expression] RPAREN {        $$ = $expression;    };NotEmptyArgumentExpressions    : Expression {        $$ = new std::vector<std::unique_ptr<NTree::IExpression>>();        $$->emplace_back($1);    }    | ArgumentExpressions COMMA Expression {        $$ = $1;        $$->emplace_back($3);    };ArgumentExpressions    : %empty {        $$ = new std::vector<std::unique_ptr<NTree::IExpression>>();    }    | NotEmptyArgumentExpressions {        $$ = $1;    };%%void Comp::CParser::error( const location_type &l, const std::string &err_message ){   std::cerr << "Error: " << err_message << " at " << l << "\n";}