%skeleton "lalr1.cc"%require  "3.0"%debug%defines%define api.namespace {Comp}%define parser_class_name {CParser}%code requires{   namespace Comp {      class CDriver;      class CScanner;   }// The following definitions is missing when %locations isn't used# ifndef YY_NULLPTR#  if defined __cplusplus && 201103L <= __cplusplus#   define YY_NULLPTR nullptr#  else#   define YY_NULLPTR 0#  endif# endif}%parse-param { CScanner  &scanner  }%parse-param { CDriver  &driver  }%code{   #include <iostream>   #include <cstdlib>   #include <fstream>   /* include for all driver functions */   #include "CDriver.h"#undef yylex#define yylex scanner.yylex}%define api.value.type variant%define parse.assert%token               END    0     "end of file"%token               LITTER%token               DIGIT%token               NUMBER%token               WS%token               COMMENT%token               STRING%token               SEMI%token               COMMA%token               ASSIGN%token               EQUAL%token               LPAREN%token               RPAREN%token               LBRACE%token               RBRACE%token               IF%token               ELSE%token               TRUE%token               FALSE%token               INT%token               BOOL%token               CLASS%token               EXTENDS%token               RETURN%token               ID%token               PLUS%token               MINUS%token               MULT%token               AND%token               OR%token               LESS%token               MOD%token               LBRACKET%token               RBRACKET%token               WHILE%token               INTARRAY%token               TSTRING%token               TSTRINGARRAY%token               PUBLIC%token               PRIVATE%token               THIS%token               NEW%token               MAIN%token               PRINT%token               NOT%token               DOT%token               LENGTH%locations%nonassoc OR%nonassoc AND%left PLUS MINUS%left MULT%right NOT%left DOT%left LBRACKET%nonassoc ASSIGN%nonassoc LESS%%Goal    : MainClass ClassDeclarations END {    };MainClass    : CLASS ID[name] LBRACE        MAIN LPAREN TSTRINGARRAY ID[args] RPAREN LBRACE            Statements        RBRACE    RBRACE {    };ClassDeclarations    : %empty {    }    | ClassDeclarations ClassDeclaration {    };ClassDeclaration    : CLASS ID[name] LBRACE        VarDeclarations        MethodDeclarations    RBRACE {    }    | CLASS ID[name] EXTENDS ID[parent] LBRACE        VarDeclarations        MethodDeclarations    RBRACE {    };NotEmptyVarDeclarationList    : VarDeclaration {    }    | NotEmptyVarDeclarationList VarDeclaration {    };VarDeclarations    : %empty {    }    | NotEmptyVarDeclarationList {    };VarDeclaration    : Type ID SEMI {    };Type    : INT {    }    | INTARRAY {    }    | BOOL {    }    | ID {    };MethodDeclarations    : %empty {    }    | MethodDeclarations MethodDeclaration {    };MethodDeclaration    : PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyVarDeclarationList        NotEmptyStatementList        RETURN Expression SEMI    RBRACE {    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyStatementList        RETURN Expression SEMI    RBRACE {    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        NotEmptyVarDeclarationList        RETURN Expression SEMI    RBRACE {    }    | PUBLIC Type[type] ID[name] LPAREN ArgumentList RPAREN LBRACE        RETURN Expression SEMI    RBRACE {    };NotEmptyArgumentList    : Type ID {    }    | NotEmptyArgumentList COMMA Type ID {    };ArgumentList    : %empty {    }    | NotEmptyArgumentList {    };NotEmptyStatementList    : Statement {    }    | NotEmptyStatementList Statement {    }Statements    : %empty {    }    | NotEmptyStatementList {    };Statement    : LBRACE Statements RBRACE {    }    | IF LPAREN Expression RPAREN Statement[trueStatement] ELSE Statement[falseStatement] {    }    | WHILE LPAREN Expression RPAREN Statement[statement] {    }    | PRINT LPAREN Expression RPAREN SEMI {    }    | ID ASSIGN Expression SEMI {    }    | ID LBRACKET Expression[index] RBRACKET ASSIGN Expression[rvalue] SEMI {    };Expression    : Expression[left] AND Expression[right] {    }    | Expression[left] LESS Expression[right] {    }    | Expression[left] PLUS Expression[right] {    }    | Expression[left] MINUS Expression[right] {    }    | Expression[left] MULT Expression[right] {    }    | Expression[array] LBRACKET Expression[index] RBRACKET {    }    | Expression[array] DOT LENGTH {    }    | Expression[object] DOT ID[methodName] LPAREN ArgumentExpressions[args] RPAREN {    }    | NUMBER {    }    | TRUE {    }    | FALSE {    }    | ID {    }    | THIS {    }    | NEW INT LBRACKET Expression[size] RBRACKET {    }    | NEW ID[clazz] LPAREN RPAREN {    }    | NOT Expression[expression] {    }    | LPAREN Expression[expression] RPAREN {    };NotEmptyArgumentExpressions    : Expression {    }    | ArgumentExpressions COMMA Expression {    };ArgumentExpressions    : %empty {    }    | NotEmptyArgumentExpressions {    };%%void Comp::CParser::error( const location_type &l, const std::string &err_message ){   std::cerr << "Error: " << err_message << " at " << l << "\n";}